
namespace AresGlobalMethods;

public static class DecodingExtents
{
	/// <summary>Количество двойных списков в тройном списке, генерируемом WordsSplit() в Ares T.</summary>
	public const int WordsListActualParts = 3;
	/// <summary>
	/// Размер блока BWT. Принимает значения 50 тыс., 100 тыс., 200 тыс., 500 тыс., 1 млн., 2 млн., 4 млн. и 16 млн.
	/// Можно было бы и еще увеличить максимальный размер, но есть риск нарваться на арифметическое переполнение.
	/// Больший размер блока увеличивает как степень сжатия (в большинстве случаев), так и время.
	/// Если размер блока меньше актуального размера фрагмента (см. <see cref="FragmentLength"/>),
	/// можно сжимать несколько блоков параллельно.
	/// Если же размер блока больше актуального размера фрагмента, это бесполезно - он все равно обрежется.
	/// </summary>
	public static int BWTBlockSize { get; set; } = 1000000;
	/// <summary>
	/// Размер, на который BWT "раздувает" каждый блок (так как в строгом смысле BWT - это алгоритм препроцессинга
	/// (см. <a href="https://github.com/Etyuhibosecyu/AresTools">здесь</a>, ниже списка файлов), а не сжатия).
	/// Это количество байт требуется для указания на номер элемента, с которого нужно начинать распаковку
	/// (после распаковки становится первым (с индексом 0)).
	/// </summary>
	public static int BWTBlockExtraSize => BWTBlockSize switch
	{
		<= 0x4000 => 2,
		<= 0x400000 => 3,
		<= 0x40000000 => 4,
		_ => 5,
	};
	/// <summary>
	/// Размер словаря в Лемпеле-Зиве. Теоретически может принимать любые значения от 1000 (меньше не имеет смысла)
	/// до актуального размера фрагмента (см. FragmentLength). Значение по умолчанию - 32767, что равно размеру словаря в ZIP.
	/// Больший размер словаря увеличивает как степень сжатия (в большинстве случаев), так и время.
	/// </summary>
	public static uint LZDictionarySize { get; set; } = 32767;
	/// <summary>
	/// Размер фрагмента, который находится в ОЗУ в каждый момент времени вместе со всеми его промежуточными представлениями -
	/// от фрагмента исходного файла до фрагмента сжатого файла. Фрагменты читаются из FileStream и записываются в FileStream
	/// строго последовательно, один за другим, параллельное сжатие или распаковка нескольких фрагментов исключены.
	/// Следует различать <b>максимальный</b> размер фрагмента, находящийся в этой переменной, и довольно часто упоминаемое
	/// со ссылкой сюда понятие <b>актуального</b> размера фрагмента, которое не тождественно этой переменной,
	/// несмотря на эти ссылки. Актуальный размер фрагмента равен меньшему из двух - этой переменной и размера сжимаемого файла.
	/// Размер фрагмента на влияет на степень сжатия, если только он не меньше размера блока BWT и словаря LZ.
	/// Влияние же на время может быть разным в зависимости от множества стохастических факторов.
	/// </summary>
	public static int FragmentLength { get; set; } = 16000000;
	/// <summary>
	/// Переменная, в которую размер фрагмента, применяемый при сжатии (см. FragmentLength), сохраняется при распаковке.
	/// </summary>
	public static int PreservedFragmentLength { get; set; } = FragmentLength;

	public static uint GetFragmentLength() => (uint)FragmentLength;

	/// <summary>
	/// Прочитать некоторое число, важное для дальнейшего процесса распаковки, записанное особым способом для экономии места
	/// в сжатом файле (универсальный метод, в разных случаях это число может означать разное).
	/// </summary>
	/// <param name="ar">Арифметический декодер, из которого число должно быть считано.</param>
	/// <param name="maxT">Максимальное количество бит в числе, должно в точности соответствовать аналогичному параметру,
	/// переданному компрессору при сжатии.</param>
	public static uint ReadNumber(this ArithmeticDecoder ar, uint maxT = 31)
	{
		var temp = (int)ar.ReadEqual(maxT);
		var read = ar.ReadEqual((uint)1 << Max(temp, 1));
		return read + ((temp == 0) ? 0 : (uint)1 << Max(temp, 1));
	}
}
